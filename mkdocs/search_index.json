{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to mingzailao Programming Blog\n\n\nThis blog is only for programming, if you like it, please fork it on Github.\n\n\nLeetCode\n\n\n\n\nWordDictionary\n\n\n\n\nThanks To:\n\n\n\n\n\u6dfb\u52a0\u4e86\u5bf9\u4e8elatex\u7684\u652f\u6301\u3002Thanks for \nissues on Github\n\n\n\n\nTODO List\n\n\n\n\n\u5bf9\u4e8eorg-mode \u8f6cmarkdown\u7684\u4f18\u5316\u3002\u4f7f\u5f97\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528;\n\n\n\u4fee\u6539\u9ed8\u8ba4\u7684org-export-to-markdown file \u7684\u5b58\u50a8\u4f4d\u7f6e\u53ef\u4ee5\u76f4\u63a5\u7531org\u751f\u6210\u76f8\u5e94\u7684markdown\u3002", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mingzailao-programming-blog", 
            "text": "This blog is only for programming, if you like it, please fork it on Github.", 
            "title": "Welcome to mingzailao Programming Blog"
        }, 
        {
            "location": "/#leetcode", 
            "text": "WordDictionary", 
            "title": "LeetCode"
        }, 
        {
            "location": "/#thanks-to", 
            "text": "\u6dfb\u52a0\u4e86\u5bf9\u4e8elatex\u7684\u652f\u6301\u3002Thanks for  issues on Github", 
            "title": "Thanks To:"
        }, 
        {
            "location": "/#todo-list", 
            "text": "\u5bf9\u4e8eorg-mode \u8f6cmarkdown\u7684\u4f18\u5316\u3002\u4f7f\u5f97\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528;  \u4fee\u6539\u9ed8\u8ba4\u7684org-export-to-markdown file \u7684\u5b58\u50a8\u4f4d\u7f6e\u53ef\u4ee5\u76f4\u63a5\u7531org\u751f\u6210\u76f8\u5e94\u7684markdown\u3002", 
            "title": "TODO List"
        }, 
        {
            "location": "/LeetCode/WordDictionary/", 
            "text": "Q211 : Add and Search Word - Data structure design\n\n\nDesign a data structure that supports the following two operations: \n\n\nvoid addWord(word)\nbool search(word)\n\n\n\n\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\n\n\nFor example:\n\n\n\naddWord(\nbad\n)\naddWord(\ndad\n)\naddWord(\nmad\n)\nsearch(\npad\n) -\n false\nsearch(\nbad\n) -\n true\nsearch(\n.ad\n) -\n true\nsearch(\nb..\n) -\n true\n\n\n\n\n#ifndef WORDDICTORY_H_\n#define WORDDICTORY_H_\n#include\nunordered_map\n\n#include\nstring\n\nusing std::string;\nusing std::unordered_map;\nclass WordDictory{\npublic:\n  struct TrieNode{\n    bool isString=false;\n    unordered_map\nchar,TrieNode*\n leaves;\n  };\nprivate:\n  TrieNode *root_;\npublic:\n  WordDictory(){\n    root_=new TrieNode;\n    root-\nisString=true;\n  }\n  void addWord(string word){\n    auto *p=_root;\n    for(const auto \n c:word){\n      if(p-\nleaves.find(c)==p-\nleaves.cend()){\n        p-\nleaves[c]=new TrieNode;\n      }\n      p=p-\nleaves[c];\n    }\n    p-\nisString=true;\n  }\n  bool search(string word){\n    return searchWord(word,_root,0)\n  }\n  bool search(string word,TrieNode *node,int s){\n    if(s==word.length()){\n      return node-\nisString;\n    }\n    if(node-\nleaves.find(word[s])!=node-\nleaves.cend()){\n      return seachWord(word,node-\nleaves[s],s+1);\n    }\n    else if(word[s]=='.'){\n      for(const auto \ni:node-\nleaves){\n        if(searchWord(word,node-\nleaves[i],s+1)){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\n#endif", 
            "title": "WordDictionary"
        }, 
        {
            "location": "/LeetCode/WordDictionary/#q211-add-and-search-word-data-structure-design", 
            "text": "Design a data structure that supports the following two operations:   void addWord(word)\nbool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.  For example:  \naddWord( bad )\naddWord( dad )\naddWord( mad )\nsearch( pad ) -  false\nsearch( bad ) -  true\nsearch( .ad ) -  true\nsearch( b.. ) -  true  #ifndef WORDDICTORY_H_\n#define WORDDICTORY_H_\n#include unordered_map \n#include string \nusing std::string;\nusing std::unordered_map;\nclass WordDictory{\npublic:\n  struct TrieNode{\n    bool isString=false;\n    unordered_map char,TrieNode*  leaves;\n  };\nprivate:\n  TrieNode *root_;\npublic:\n  WordDictory(){\n    root_=new TrieNode;\n    root- isString=true;\n  }\n  void addWord(string word){\n    auto *p=_root;\n    for(const auto   c:word){\n      if(p- leaves.find(c)==p- leaves.cend()){\n        p- leaves[c]=new TrieNode;\n      }\n      p=p- leaves[c];\n    }\n    p- isString=true;\n  }\n  bool search(string word){\n    return searchWord(word,_root,0)\n  }\n  bool search(string word,TrieNode *node,int s){\n    if(s==word.length()){\n      return node- isString;\n    }\n    if(node- leaves.find(word[s])!=node- leaves.cend()){\n      return seachWord(word,node- leaves[s],s+1);\n    }\n    else if(word[s]=='.'){\n      for(const auto  i:node- leaves){\n        if(searchWord(word,node- leaves[i],s+1)){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\n#endif", 
            "title": "Q211 : Add and Search Word - Data structure design"
        }, 
        {
            "location": "/LeetCode/ThreeSum/", 
            "text": "Q15 : 3Sum\n\n\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote: The solution set must not contain duplicate triplets.\n\n\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n\n\n#include\nvector\n\n#include\nalgorithm\n\n#include\niterator\n\n#include\niostream\n\n#include\niostream\n\nusing namespace std;\nclass Solution;\nclass Solution {\npublic:\n  /**\n   * @param numbers : Give an array numbers of n integer\n   * @return : Find all unique triplets in the array which gives the sum of zero.\n   */\n  vector\nvector\nint\n threeSum(vector\nint\n \nnums){\n    vector\nvector\nint\n ans;\n    const int target=0;\n    std::sort(nums.begin(), nums.end());\n    for(vector\nint\n::size_type i=0;i!=nums.size()-2;i++){\n      if(i==0||nums[i]!=nums[i-1]){\n        for(vector\nint\n::size_type j=i+1,k=nums.size()-1;j\nk;){\n          if(j-1\ni\n nums[j]==nums[j-1]){\n            ++j;\n          }\n          else if(k+1\nnums.size()\nnums[k]==nums[k+1]){\n            --k;\n          }\n          else{\n            const auto sum=nums[i]+nums[j]+nums[k];\n            if(sum\ntarget){\n              --k;\n            }\n            else if(sum\ntarget){\n              ++j;\n            }\n            else{\n              ans.push_back({nums[i],nums[j],nums[k]});\n              ++j,--k;\n            }\n          }\n\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main(){\n  vector\nint\n a={-1,0,1,2,-1,-4};\n  Solution solution;\n  for(const auto item:solution.threeSum(a)){\n    for(const auto i:item){\n      std::cout\ni\n \n;\n    }\n    std::cout\nstd::endl;\n  }\n}", 
            "title": "ThreeSum"
        }, 
        {
            "location": "/LeetCode/ThreeSum/#q15-3sum", 
            "text": "Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote: The solution set must not contain duplicate triplets.  For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]  #include vector \n#include algorithm \n#include iterator \n#include iostream \n#include iostream \nusing namespace std;\nclass Solution;\nclass Solution {\npublic:\n  /**\n   * @param numbers : Give an array numbers of n integer\n   * @return : Find all unique triplets in the array which gives the sum of zero.\n   */\n  vector vector int  threeSum(vector int   nums){\n    vector vector int  ans;\n    const int target=0;\n    std::sort(nums.begin(), nums.end());\n    for(vector int ::size_type i=0;i!=nums.size()-2;i++){\n      if(i==0||nums[i]!=nums[i-1]){\n        for(vector int ::size_type j=i+1,k=nums.size()-1;j k;){\n          if(j-1 i  nums[j]==nums[j-1]){\n            ++j;\n          }\n          else if(k+1 nums.size() nums[k]==nums[k+1]){\n            --k;\n          }\n          else{\n            const auto sum=nums[i]+nums[j]+nums[k];\n            if(sum target){\n              --k;\n            }\n            else if(sum target){\n              ++j;\n            }\n            else{\n              ans.push_back({nums[i],nums[j],nums[k]});\n              ++j,--k;\n            }\n          }\n\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main(){\n  vector int  a={-1,0,1,2,-1,-4};\n  Solution solution;\n  for(const auto item:solution.threeSum(a)){\n    for(const auto i:item){\n      std::cout i   ;\n    }\n    std::cout std::endl;\n  }\n}", 
            "title": "Q15 : 3Sum"
        }, 
        {
            "location": "/LeetCode/ThreeSumClosest/", 
            "text": "Q16 : 3Sum Closest\n\n\nGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n\n    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n\n\n\n#include\nvector\n\n#include\nalgorithm\n\n#include\niterator\n\n#include\niostream\n\n#include\niostream\n\n#include\nnumeric\n\nusing namespace std;\nclass Solution;\nclass Solution {\npublic:\n  /**\n   * @param numbers : Give an array numbers of n integer\n   * @return : Find all unique triplets in the array which gives the sum of zero.\n   */\n  int threeSumClosest(vector\nint\n nums,int target){\n    int ans =numeric_limits\nint\n::max();\n    int min_diff = numeric_limits\nint\n::max();\n    std::sort(nums.begin(), nums.end());\n    for(vector\nint\n::size_type i=0;i!=nums.size()-2;i++){\n      if(i==0||nums[i]!=nums[i-1]){\n        vector\nint\n::size_type j=i+1;\n        vector\nint\n::size_type k=nums.size()-1;\n        while(j\nk){\n          const auto sum=nums[i]+nums[j]+nums[k];\n          if(sum\ntarget){\n            --k;\n          }\n          else if(sum\ntarget){\n            ++j;\n          }\n          else{\n            return target;\n          }\n          if(abs(sum-target)\nmin_diff){\n            min_diff=abs(sum-target);\n            ans=sum;\n          }\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main(){\n  vector\nint\n a={-1,0,1,2,-1,-4};\n  Solution solution;\n  std::cout\nsolution.threeSumClosest(a,1)\nstd::endl;\n}", 
            "title": "ThreeSumClosest"
        }, 
        {
            "location": "/LeetCode/ThreeSumClosest/#q16-3sum-closest", 
            "text": "Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.      For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).  #include vector \n#include algorithm \n#include iterator \n#include iostream \n#include iostream \n#include numeric \nusing namespace std;\nclass Solution;\nclass Solution {\npublic:\n  /**\n   * @param numbers : Give an array numbers of n integer\n   * @return : Find all unique triplets in the array which gives the sum of zero.\n   */\n  int threeSumClosest(vector int  nums,int target){\n    int ans =numeric_limits int ::max();\n    int min_diff = numeric_limits int ::max();\n    std::sort(nums.begin(), nums.end());\n    for(vector int ::size_type i=0;i!=nums.size()-2;i++){\n      if(i==0||nums[i]!=nums[i-1]){\n        vector int ::size_type j=i+1;\n        vector int ::size_type k=nums.size()-1;\n        while(j k){\n          const auto sum=nums[i]+nums[j]+nums[k];\n          if(sum target){\n            --k;\n          }\n          else if(sum target){\n            ++j;\n          }\n          else{\n            return target;\n          }\n          if(abs(sum-target) min_diff){\n            min_diff=abs(sum-target);\n            ans=sum;\n          }\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main(){\n  vector int  a={-1,0,1,2,-1,-4};\n  Solution solution;\n  std::cout solution.threeSumClosest(a,1) std::endl;\n}", 
            "title": "Q16 : 3Sum Closest"
        }, 
        {
            "location": "/LeetCode/FourSum/", 
            "text": "Q18 : 4Sum\n\n\nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\n\nNote: The solution set must not contain duplicate quadruplets.\n\n\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n\n\n\n\n#include\nalgorithm\n\n#include\nvector\n\n#include\niostream\n\nusing namespace std;\n\n\nclass Solution;\nclass Solution{\npublic:\n  vector\nvector\nint\n \n fourSum(vector\nint\n \nnum, int target){\n    vector\nint\n::size_type left,right;\n    int sum;\n    std::sort(num.begin(), num.end());\n    vector\nvector\nint\n result;\n    for(vector\nint\n::size_type i=0;i\nnum.size()-3;i++){\n      if(i\n num[i]==num[i-1]){\n        continue;\n      }\n      for(vector\nint\n::size_type j=i+1;j\nnum.size()-2;j++){\n        if(j!=i+1\n num[j]==num[j-1]){\n          continue;\n        }\n        sum=target-num[i]-num[j];\n        left=j+1;\n        right=num.size()-1;\n        while(left\nright){\n          if(num[left]+num[right]==sum){\n            result.push_back({num[i],num[j],num[left],num[right]});\n            ++left;\n            --right;\n            while(left\nright\nnum[left]==num[left-1]){\n              ++left;\n            }\n            while(left\nright\nnum[right]==num[right+1]){\n              --right;\n            }\n          }\n          else{\n            if(num[left]+num[right]\nsum){\n              --right;\n            }\n            else{\n              ++left;\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\n\n\nint main(){\n  vector\nint\n a={-1,0,1,2,-1,-4};\n  Solution solution;\n  for(const auto item:solution.fourSum(a,0)){\n    for(const auto i:item){\n      std::cout\ni\n \n;\n    }\n    std::cout\nstd::endl;\n  }\n}", 
            "title": "FourSum"
        }, 
        {
            "location": "/LeetCode/FourSum/#q18-4sum", 
            "text": "Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.  Note: The solution set must not contain duplicate quadruplets.  For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]  #include algorithm \n#include vector \n#include iostream \nusing namespace std;\n\n\nclass Solution;\nclass Solution{\npublic:\n  vector vector int    fourSum(vector int   num, int target){\n    vector int ::size_type left,right;\n    int sum;\n    std::sort(num.begin(), num.end());\n    vector vector int  result;\n    for(vector int ::size_type i=0;i num.size()-3;i++){\n      if(i  num[i]==num[i-1]){\n        continue;\n      }\n      for(vector int ::size_type j=i+1;j num.size()-2;j++){\n        if(j!=i+1  num[j]==num[j-1]){\n          continue;\n        }\n        sum=target-num[i]-num[j];\n        left=j+1;\n        right=num.size()-1;\n        while(left right){\n          if(num[left]+num[right]==sum){\n            result.push_back({num[i],num[j],num[left],num[right]});\n            ++left;\n            --right;\n            while(left right num[left]==num[left-1]){\n              ++left;\n            }\n            while(left right num[right]==num[right+1]){\n              --right;\n            }\n          }\n          else{\n            if(num[left]+num[right] sum){\n              --right;\n            }\n            else{\n              ++left;\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\n\n\nint main(){\n  vector int  a={-1,0,1,2,-1,-4};\n  Solution solution;\n  for(const auto item:solution.fourSum(a,0)){\n    for(const auto i:item){\n      std::cout i   ;\n    }\n    std::cout std::endl;\n  }\n}", 
            "title": "Q18 : 4Sum"
        }, 
        {
            "location": "/LeetCode/IsAddictiveNumber/", 
            "text": "Q306 : Additive Number\n\n\nAdditive number is a string whose digits can form additive sequence.\n\n\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\n\nFor example:\n\n112358\n is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.\n\n\n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\n\n\n\n199100199\n is also an additive number, the additive sequence is: 1, 99, 100, 199.\n\n\n1 + 99 = 100, 99 + 100 = 199\n\n\n\n\nNote\n: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\n\nGiven a string containing only digits \n0\n-\n9\n, write a function to determine if it\ns an additive number.\n\n\n#include\niostream\n\n#include\nalgorithm\n\n#include\nstring\n\n#include\nnumeric\n\n\nusing std::max;\nusing std::string;\n\nclass Solution{\nprivate:\n  string add(const string\n a,const string\n b){\n    string result;\n    string::size_type reslen=max(a.length(),b.length());\n    int carry=0;\n    for(string::size_type i=0;i\nreslen;++i){\n      int a_digit_i=i\na.length()?a[i]-'0':0;\n      int b_digit_i=i\nb.length()?b[i]-'0':0;\n      int sum=carry+a_digit_i+b_digit_i;\n      carry=sum/10;\n      sum=sum%10;\n      result.push_back('0'+sum);\n    }\n    if(carry){\n      result.push_back('0'+carry);\n    }\n    std::reverse(result.begin(),result.end());\n    return result;\n  }\npublic:\n  bool isAdditiveNumber(string num){\n    for(int i=1;i\nnum.length();++i){\n      for(int j=i+1;j\nnum.length();++j){\n        string s1=num.substr(0,i);\n        string s2=num.substr(i,j-i);\n        if((s1.length()\n1\ns1[0]=='0')||\n          (s2.length()\n1\ns2[0]=='0')){\n            continue;\n          }\n        string next=add(s1,s2);\n        string cur=s1+s2+next;\n        while(cur.length()\nnum.length()){\n          s1=s2;\n          s2=next;\n          next=add(s1,s2);\n          cur+=next;\n        }\n        if(cur==num){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};", 
            "title": "IsAdditiveNumber"
        }, 
        {
            "location": "/LeetCode/IsAddictiveNumber/#q306-additive-number", 
            "text": "Additive number is a string whose digits can form additive sequence.  A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.  For example: 112358  is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.  1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  199100199  is also an additive number, the additive sequence is: 1, 99, 100, 199.  1 + 99 = 100, 99 + 100 = 199  Note : Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.  Given a string containing only digits  0 - 9 , write a function to determine if it s an additive number.  #include iostream \n#include algorithm \n#include string \n#include numeric \n\nusing std::max;\nusing std::string;\n\nclass Solution{\nprivate:\n  string add(const string  a,const string  b){\n    string result;\n    string::size_type reslen=max(a.length(),b.length());\n    int carry=0;\n    for(string::size_type i=0;i reslen;++i){\n      int a_digit_i=i a.length()?a[i]-'0':0;\n      int b_digit_i=i b.length()?b[i]-'0':0;\n      int sum=carry+a_digit_i+b_digit_i;\n      carry=sum/10;\n      sum=sum%10;\n      result.push_back('0'+sum);\n    }\n    if(carry){\n      result.push_back('0'+carry);\n    }\n    std::reverse(result.begin(),result.end());\n    return result;\n  }\npublic:\n  bool isAdditiveNumber(string num){\n    for(int i=1;i num.length();++i){\n      for(int j=i+1;j num.length();++j){\n        string s1=num.substr(0,i);\n        string s2=num.substr(i,j-i);\n        if((s1.length() 1 s1[0]=='0')||\n          (s2.length() 1 s2[0]=='0')){\n            continue;\n          }\n        string next=add(s1,s2);\n        string cur=s1+s2+next;\n        while(cur.length() num.length()){\n          s1=s2;\n          s2=next;\n          next=add(s1,s2);\n          cur+=next;\n        }\n        if(cur==num){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};", 
            "title": "Q306 : Additive Number"
        }, 
        {
            "location": "/LeetCode/numberOfArithmeticSlices/", 
            "text": "Q413 : Arithmetic Slices\n\n\nA sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\n\nFor example, these are arithmetic sequence:\n\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\n\n\n\nThe following sequence is not arithmetic.\n\n\n1, 1, 2, 5, 7\n\n\n\n\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 \n= P \n Q \n N.\n\n\nA slice (P, Q) of array A is called arithmetic if the sequence:\nA[P], A[p + 1], \n, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 \n Q.\n\n\nThe function should return the number of arithmetic slices in the array A.\n\n\nExample:\n\n\nA = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\n\n\n\n\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector\nint\n A) {\n        int res = 0, i = 0;\n        for (int i = 0; i + 2 \n A.size(); ++i) {\n            const auto start = i;\n            while (i + 2 \n A.size() \n A[i + 2] + A[i] == 2 * A[i + 1]) {\n                res += (i++) - start + 1;\n            }\n        }\n        return res;\n    }\n};", 
            "title": " Arithmetic Slices"
        }, 
        {
            "location": "/LeetCode/numberOfArithmeticSlices/#q413-arithmetic-slices", 
            "text": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.  For example, these are arithmetic sequence:  1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9  The following sequence is not arithmetic.  1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0  = P   Q   N.  A slice (P, Q) of array A is called arithmetic if the sequence:\nA[P], A[p + 1],  , A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1   Q.  The function should return the number of arithmetic slices in the array A.  Example:  A = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  class Solution {\npublic:\n    int numberOfArithmeticSlices(vector int  A) {\n        int res = 0, i = 0;\n        for (int i = 0; i + 2   A.size(); ++i) {\n            const auto start = i;\n            while (i + 2   A.size()   A[i + 2] + A[i] == 2 * A[i + 1]) {\n                res += (i++) - start + 1;\n            }\n        }\n        return res;\n    }\n};", 
            "title": "Q413 : Arithmetic Slices"
        }
    ]
}